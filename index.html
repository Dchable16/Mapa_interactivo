<!DOCTYPE html>
<html lang="es">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net 'unsafe-eval'; font-src 'self' data: https://cdn.jsdelivr.net; img-src 'self' data: https://cdn.jsdelivr.net https://github.com https://raw.githubusercontent.com maps.googleapis.com *.gstatic.com mapstreet.com tile.openstreetmap.org mt1.google.com mt0.google.com *.khms.googleapis.com;">
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Mapa interactivo Tiendas 3B</title>
    <link rel="icon" href="favicon.png"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>
    
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    
    <style>
        /* Estilos generales para el documento */
        html, body { height: 100%; margin: 0; }
        
        /* Estilo del contenedor del mapa */
        #map { width: 100%; height: 100%; /* Ajustar altura del mapa */ }
        
        /* Estilos para el marcador amarillo */
        .red-marker {background-color: Red; border: 3px solid white; border-radius: 50%; width: 20px; height: 20px; display: inline-block; }
        
        /* Estilo para la etiqueta del marcador */
        .marker-label { position: absolute; top: -40px; left: 50%; transform: translateX(-50%); color: red; text-shadow: 1px 1px 0 white, -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white; font-weight: bold; font-size: 14px; white-space: nowrap; padding: 5px; }
        
        /* Estilos para el contenedor del formulario */
        .form-container { background-color: rgb(248, 248, 255); padding: 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); margin: 20px auto; max-width: 600px; }
        
        /* Estilos para las etiquetas del formulario */
        .form-container label { color: rgb(0, 187, 45); font-weight: bold; }
        
        /* Estilos para los campos de entrada del formulario */
        .form-container input { margin-bottom: 10px; padding: 5px; border: 1px solid rgb(0, 187, 45); border-radius: 5px; width: calc(100% - 12px); }
        
        /* Estilos para los botones del formulario */
        .form-container button { background-color: rgb(230, 25, 25); color: white; border: none; border-radius: 5px; padding: 10px; cursor: pointer; width: 100%; font-weight: bold; }
        .form-container button:hover { background-color: rgb(200, 25, 25); } /* Estilo al pasar el mouse */
        
        /* Estilo para el contenedor de botones */
        .button-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        
        /* Estilo para el logotipo */
        .logo { display: block; margin: 0 auto 20px; width: 80px; }
        
        /* Estilo para centrar el título */
        .centered-title { text-align: center; margin: 20px 0; }
        
        /* Estilo para las filas del formulario */
        .form-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .form-column { display: flex; flex-direction: column; }
        
        /* Media queries para diseño responsivo */
        @media (max-width: 768px) {
            .form-row { grid-template-columns: 1fr; }
            .button-container { grid-template-columns: 1fr; }
            .logo { width: 80px; }
            body { padding: 8px; margin: 0; height: 100%;  }
        }
        
        @media (min-width: 1024px) {
            .form-container { max-width: 65%; padding: 30px; }
            .form-container input, .form-container button { padding: 5px; font-size: 15px; }
            .logo { width: 120px; }
        }

        .layer-control-container {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            z-index: 1000; /* Asegúrate de que esté por encima de otros elementos */
        }
    </style>
</head>
<body>
    <div class="header-container">
        <h1 class="centered-title">Mapa interactivo Tiendas 3B</h1> <img src="https://raw.githubusercontent.com/Dchable16/Mapa_interactivo/main/Captura-removebg-preview.png" alt="Logotipo" class="logo"> </div>
    
    <div class="form-container">
        <div class="form-row">
            <div class="form-column">
                <label for="lat">Latitud:</label>
                <input type="text" id="lat" value="19.4326"> </div>
            <div class="form-column">
                <label for="lon">Longitud:</label>
                <input type="text" id="lon" value="-99.1332"> </div>
            <div class="form-column">
                <label for="markerName">Nombre del Marcador:</label>
                <input type="text" id="markerName" value="Marcador Manual"> </div>
        </div>
        
        <div class="button-container">
            <button onclick="addMarker()">Agregar Marcador</button>
            <button onclick="removeMarker()">Eliminar Marcador</button>
            <button onclick="addRadius(400)">Agregar Radio 400m</button>
            <button onclick="addRadius(800)">Agregar Radio 800m</button>
            <button onclick="calculateDifference()">Calcular Diferencia entre Radios</button>
            <button onclick="extractBufferData()">Extraer Información Ageb - Radio 400m</button>
            <button onclick="extractDifferenceData()">Extraer Información Ageb - Radio 800m</button>
            <button id="useLocationBtn">Usar Localización</button>
        </div>
    </div>
    
    <div id="map" style="position: relative;"> <div id="zoom-level" title="Nivel del Zoom" style="background-color: rgb(255, 255, 255); color: black; border-radius: 2px; padding: 8.5px; cursor: default; text-align: center; font-weight: bold; position: absolute; top: 75px; left: 11.5px; z-index: 1000; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);">
            <span id="zoom-value">12</span> </div>

        <button id="center-button" title="Centrar en el marcador" style="position: absolute; bottom: 60px; left: 10px; z-index: 1000; background-color: white; border: 1px solid #ccc; border-radius: 8px; width: 40px; height: 40px; cursor: pointer; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); padding: 5px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3c4043" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3" fill="#3c4043" />
                <path d="M12 2v2M2 12h2M12 22v-2M22 12h-2M12 6v-2M6 12h-2M12 18v2M18 12h2" />
            </svg>
        </button>
        
        <button id="realtime-location-button" title="Localización en tiempo real" style="position: absolute; bottom: 110px; left: 10px; z-index: 1000; background-color: white; border: 1px solid #ccc; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); padding: 8px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3c4043" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10" fill="none" stroke="#3c4043" stroke-width="2" />
                <circle cx="12" cy="12" r="3" fill="#3c4043" />
            </svg>
        </button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script> <script>
        // Inicializar el mapa centrado en las coordenadas especificadas
        const map = L.map("map").setView([19.4326, -99.1332], 12);
        
        // Inicializar el contenedor de control de capas
        const layerControlContainer = L.control({ position: 'topright' }); // Inicializar la variable aquí

        map.on('zoomend', function() {
            document.getElementById('zoom-value').textContent = map.getZoom();
        });
        
        // Agregar el control de escala dinámica al mapa
        L.control.scale({
            position: 'bottomleft', // Posición del control
            metric: true,             // Mostrar escala métrica
            imperial: false           // No mostrar escala imperial
        }).addTo(map);

        // Función para centrar el mapa en el marcador
        document.getElementById('center-button').addEventListener('click', function() {
            if (currentMarker) {
                map.setView(currentMarker.getLatLng(), map.getZoom()); // Centrar el mapa en el marcador
            } else {
                alert("No hay ningún marcador en el mapa para centrar.");
            }
        });

        // Capas base del mapa
        const osmLayer = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "&copy; <a href='https://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors"
        }).addTo(map); // Añadir capa de OpenStreetMap al mapa

        const googleRoadLayer = L.tileLayer("https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}", { attribution: "Google" });
        const googleHybridLayer = L.tileLayer("https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", { attribution: "Google" });

        // Definición de capas GeoJSON
        const geoJsonLayersAgeb = {};
        const geoJsonLayersUsoSuelo = {};
        const geoJsonLayersAlcaldias = {};
        const geoJsonLayersPoligonos = {};
        const geoJsonLayersColonias = {};
        const geoJsonLayersCompetencias = {};
        
        // Variables para el marcador y los radios
        let currentMarker = null;
        let radius400m = null;
        let radius800m = null;
        let differenceLayer = null;

        // Grupos de capas para los radios y la diferencia
        const radius400Layer = L.layerGroup().addTo(map);
        const radius800Layer = L.layerGroup().addTo(map);
        const differenceLayerGroup = L.layerGroup().addTo(map);
        const bufferLayerGroup = L.layerGroup().addTo(map);
        const differenceExtractionLayerGroup = L.layerGroup().addTo(map);

        // Banderas para controlar la creación de elementos
        let radius400Created = false;
        let radius800Created = false;
        let differenceCreated = false;
        let bufferDataExtracted = false;
        let differenceDataExtracted = false;

        // Conjunto para rastrear capas ya cargadas
        const loadedLayers = new Set();

        // Función para agregar un marcador en el mapa
        function addMarker() {
            if (currentMarker) {
                alert("Ya existe un marcador en el mapa. Elimínelo antes de agregar uno nuevo.");
                return;
            }
            
            const lat = parseFloat(document.getElementById('lat').value);
            const lon = parseFloat(document.getElementById('lon').value);
            const markerName = document.getElementById('markerName').value;
            
            console.log(`Intentando agregar marcador en lat: ${lat}, lon: ${lon}`); // Log para verificar coordenadas
            
            // Validar coordenadas
            if (isNaN(lat) || isNaN(lon)) {
                alert("Por favor ingrese coordenadas válidas.");
                return;
            }
            
            if (lat < -90 || lat > 90) {
                alert("La latitud debe estar entre -90 y 90 grados.");
                return;
            }
            
            if (lon < -180 || lon > 180) {
                alert("La longitud debe estar entre -180 y 180 grados.");
                return;
            }
            
            try {
                // Crear el nuevo marcador amarillo sin el popup
                currentMarker = L.marker([lat, lon], {
                    icon: L.divIcon({ className: 'red-marker', iconSize: [12, 12], iconAnchor: [10, 20] })
                }).addTo(map); // Eliminar la parte de bindPopup()
                
                // Crear la etiqueta del marcador
                currentMarkerLabel = L.divIcon({
                    className: 'marker-label',
                    html: markerName,
                    iconSize: [100, 50],
                    iconAnchor: [50, 15]
                });
                L.marker([lat, lon], { icon: currentMarkerLabel }).addTo(map); // Añadir la etiqueta al mapa
                
                map.setView([lat, lon], 12); // Centrar el mapa en el nuevo marcador
            } catch (error) {
                console.error("Error al agregar el marcador:", error);
                alert("Ocurrió un error al agregar el marcador. Verifique la consola para más detalles.");
            }
        }
        
        function removeMarker() {
            if (currentMarker) {
                map.removeLayer(currentMarker); // Eliminar el marcador del mapa
                const latLng = currentMarker.getLatLng(); // Guardar las coordenadas del marcador
                currentMarker = null; // Limpiar la variable del marcador
                
                // Eliminar la etiqueta del marcador si existe
                if (currentMarkerLabel) {
                    map.eachLayer(function(layer) {
                        if (layer instanceof L.Marker && layer.getLatLng && layer.getLatLng().equals(latLng)) {
                            map.removeLayer(layer); // Eliminar la etiqueta del mapa
                        }
                    });
                    currentMarkerLabel = null; // Limpiar la variable de la etiqueta
                }
                
                // Limpiar las capas de radios y restablecer las banderas
                radius400Layer.clearLayers(); // Limpiar las capas de radios
                radius800Layer.clearLayers();
                radius400Created = false; // Reiniciar la bandera de creación de radio 400m
                radius800Created = false; // Reiniciar la bandera de creación de radio 800m
                
                // Limpiar las capas de extracción y restablecer las banderas
                bufferLayerGroup.clearLayers(); // Limpiar las capas de buffer
                differenceExtractionLayerGroup.clearLayers(); // Limpiar las capas de extracción
                differenceLayerGroup.clearLayers(); // Limpiar la capa de diferencia
                bufferDataExtracted = false; // Reiniciar la bandera de extracción de buffer
                differenceDataExtracted = false; // Reiniciar la bandera de extracción de diferencia
                differenceCreated = false; // Reiniciar la bandera de diferencia
                
                // Limpiar los campos de entrada
                document.getElementById('lat').value = ''; // Limpiar el campo de latitud
                document.getElementById('lon').value = ''; // Limpiar el campo de longitud
                document.getElementById('markerName').value = ''; // Limpiar el campo de nombre del marcador
            } else {
                alert("No hay ningún marcador para eliminar.");
            }
        }

        // Función para agregar radios de 400m o 800m alrededor del marcador
        function addRadius(radius) {
            if (radius === 400 && radius400Created) {
                alert("El radio de 400m ya ha sido creado.");
                return; // Evitar agregar un nuevo radio si ya existe
            }
            if (radius === 800 && radius800Created) {
                alert("El radio de 800m ya ha sido creado.");
                return; // Evitar agregar un nuevo radio si ya existe
            }

            if (currentMarker) {
                const latLng = currentMarker.getLatLng();
                const circle = L.circle(latLng, { color: radius === 400 ? 'blue' : 'red', fillOpacity: 0.2, radius: radius });
                if (radius === 400) {
                    radius400Layer.addLayer(circle); // Añadir el círculo de 400m al grupo de capas
                    radius400m = circle; // Guardar el círculo en la variable
                    radius400Created = true; // Marcar como creado
                } else {
                    radius800Layer.addLayer(circle); // Añadir el círculo de 800m al grupo de capas
                    radius800m = circle; // Guardar el círculo en la variable
                    radius800Created = true; // Marcar como creado
                }
            } else {
                alert("Primero debe agregar un marcador.");
            }
        }
        
        // Función para calcular la diferencia entre dos círculos
        function calculateDifference() {
            if (differenceCreated) {
                alert("La diferencia entre radios ya ha sido calculada.");
                return; // Evitar calcular la diferencia si ya se ha hecho
            }

            if (currentMarker && radius400m && radius800m) {
                const latLng = currentMarker.getLatLng();
                const circle400 = turf.circle([latLng.lng, latLng.lat], 400, { units: 'meters' });
                const circle800 = turf.circle([latLng.lng, latLng.lat], 800, { units: 'meters' });
                const difference = turf.difference(circle800, circle400); // Calcular la diferencia entre los círculos
                if (difference) {
                    const geoJson = turf.featureCollection([difference]);
                    differenceLayer = L.geoJSON(geoJson, { style: { color: 'green', weight: 2, fillOpacity: 0.5 } }).addTo(differenceLayerGroup);
                    differenceCreated = true; // Marcar como creado
                } else {
                    alert("No se pudo calcular la diferencia entre los círculos.");
                }
            } else {
                alert("Asegúrese de que el marcador y ambos radios estén creados.");
            }
        }

        // Función para extraer información de las capas Ageb - Buffer
        function extractBufferData() {
            if (bufferDataExtracted) {
                alert("La extracción de datos Ageb con el radio de 400m ya ha sido realizada.");
                return;
            }
            
            if (currentMarker) {
                const latLng = currentMarker.getLatLng();
                const point = turf.point([latLng.lng, latLng.lat]);
                let selectedLayer = null;
                
                if (agebCDMXLayer && agebCDMXLayer.toGeoJSON().features.some(feature => turf.booleanPointInPolygon(point, feature))) {
                    selectedLayer = agebCDMXLayer.toGeoJSON();
                } else if (agebEdoMexLayer && agebEdoMexLayer.toGeoJSON().features.some(feature => turf.booleanPointInPolygon(point, feature))) {
                    selectedLayer = agebEdoMexLayer.toGeoJSON();
                }
                
                if (selectedLayer) {
                    const buffer = turf.circle([latLng.lng, latLng.lat], 400, { units: 'meters' });
                    const featuresWithinBuffer = turf.featureCollection(selectedLayer.features.map(feature => {
                        const intersection = turf.intersect(feature, buffer);
                        if (intersection) {
                            const originalArea = Math.floor(turf.area(feature));
                            const extractedArea = Math.floor(turf.area(intersection));
                            const extractionPercentage = (extractedArea / originalArea) * 100;
                            const populationTotal = (extractionPercentage / 100) * feature.properties.POB1;
                            
                            intersection.properties.originalArea = originalArea;
                            intersection.properties.extractedArea = extractedArea;
                            intersection.properties.extractionPercentage = extractionPercentage;
                            intersection.properties.populationTotal = Math.floor(populationTotal);
                            
                            return intersection;
                        }
                        return null;
                    }).filter(feature => feature !== null));
                    
                    bufferLayerGroup.clearLayers();
                    
                    L.geoJSON(featuresWithinBuffer, {
                        style: { color: 'orange', weight: 2, fillOpacity: 0.5 },
                        onEachFeature: function (feature, layer) {
                            layer.on('click', function () {
                                let popupContent = "<b>Atributos:</b><br>";
                                for (const key in feature.properties) {
                                    popupContent += `${key}: ${feature.properties[key]}<br>`;
                                }
                                layer.bindPopup(popupContent).openPopup();
                            });
                        }
                    }).addTo(bufferLayerGroup);
                    bufferDataExtracted = true;
                } else {
                    alert("El marcador no está dentro de ninguna capa AGEB.");
                }
            } else {
                alert("Primero debe agregar un marcador.");
            }
        }

        // Función para extraer información de las capas Ageb - Diferencia
        function extractDifferenceData() {
            if (differenceDataExtracted) {
                alert("La extracción de datos Ageb con el radio de 800m ya ha sido realizada.");
                return;
            }
            
            if (currentMarker) {
                const latLng = currentMarker.getLatLng();
                const point = turf.point([latLng.lng, latLng.lat]);
                let selectedLayer = null;
                
                if (agebCDMXLayer && agebCDMXLayer.toGeoJSON().features.some(feature => turf.booleanPointInPolygon(point, feature))) {
                    selectedLayer = agebCDMXLayer.toGeoJSON();
                } else if (agebEdoMexLayer && agebEdoMexLayer.toGeoJSON().features.some(feature => turf.booleanPointInPolygon(point, feature))) {
                    selectedLayer = agebEdoMexLayer.toGeoJSON();
                }
                
                if (selectedLayer) {
                    const circle400 = turf.circle([latLng.lng, latLng.lat], 400, { units: 'meters' });
                    const circle800 = turf.circle([latLng.lng, latLng.lat], 800, { units: 'meters' });
                    const difference = turf.difference(circle800, circle400);
                    
                    if (difference) {
                        const featuresWithinDifference = turf.featureCollection(selectedLayer.features.map(feature => {
                            const intersection = turf.intersect(feature, difference);
                            if (intersection) {
                                const originalArea = Math.floor(turf.area(feature));
                                const extractedArea = Math.floor(turf.area(intersection));
                                const extractionPercentage = (extractedArea / originalArea) * 100;
                                const populationTotal = (extractionPercentage / 100) * feature.properties.POB1;
                                
                                intersection.properties.originalArea = originalArea;
                                intersection.properties.extractedArea = extractedArea;
                                intersection.properties.extractionPercentage = extractionPercentage;
                                intersection.properties.populationTotal = Math.floor(populationTotal);
                                
                                return intersection;
                            }
                            return null;
                        }).filter(feature => feature !== null));
                        
                        differenceExtractionLayerGroup.clearLayers();
                        
                        L.geoJSON(featuresWithinDifference, {
                            style: { color: 'purple', weight: 2, fillOpacity: 0.5 },
                            onEachFeature: function (feature, layer) {
                                layer.on('click', function () {
                                    let popupContent = "<b>Atributos:</b><br>";
                                    for (const key in feature.properties) {
                                        popupContent += `${key}: ${feature.properties[key]}<br>`;
                                    }
                                    layer.bindPopup(popupContent).openPopup();
                                });
                            }
                        }).addTo(differenceExtractionLayerGroup);
                        differenceDataExtracted = true;
                    } else {
                        alert("No se pudo calcular la diferencia entre los círculos.");
                    }
                } else {
                    alert("El marcador no está dentro de ninguna capa AGEB.");
                }
            } else {
                alert("Primero debe agregar un marcador.");
            }
        }

        // Cargar capas GeoJSON desde archivos locales
        function loadGeoJsonLayer(filePath, layerGroup, layerName, style, onEachFeatureCallback) {
            fetch(filePath)
                .then(response => response.json())
                .then(data => {
                    if (layerName === 'usoSuelo') {
                        data.features = data.features.map(feature => {
                            if (feature.geometry.type === 'Polygon') {
                                feature.geometry.coordinates = feature.geometry.coordinates.map(polygon => polygon.map(ring => ring.map(coord => [parseFloat(coord[0].toFixed(5)), parseFloat(coord[1].toFixed(5))])));
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                feature.geometry.coordinates = feature.geometry.coordinates.map(polygons => polygons.map(polygon => polygon.map(ring => ring.map(coord => [parseFloat(coord[0].toFixed(5)), parseFloat(coord[1].toFixed(5))]))));
                            }
                            return feature;
                        });
                    }
                    
                    const layer = L.geoJSON(data, { style: style, onEachFeature: onEachFeatureCallback });
                    layerGroup[layerName] = layer;
                    loadedLayers.add(layerName);
                    
                    if (layerName === 'agebCDMX' || layerName === 'agebEdoMex') {
                        layer.addTo(map);
                    }
                    
                    updateLayerControl();
                })
                .catch(error => console.error(`Error loading ${layerName} layer:`, error));
        }
        
        // Estilos para las capas GeoJSON
        const agebStyle = { color: 'gray', weight: 1, fillOpacity: 0.2 };
        const usoSueloStyle = { color: 'green', weight: 1, fillOpacity: 0.2 };
        const alcaldiasStyle = { color: 'purple', weight: 2, fillOpacity: 0 };
        const municipiosStyle = { color: 'blue', weight: 2, fillOpacity: 0 };
        const poligonosStyle = { color: 'orange', weight: 2, fillOpacity: 0 };
        const coloniasStyle = { color: 'brown', weight: 1, fillOpacity: 0.2 };
        const competenciasStyle = { color: 'red', weight: 1, fillOpacity: 0.2 };

        // Cargar capas GeoJSON al inicio
        loadGeoJsonLayer('ageb_cdmx.geojson', geoJsonLayersAgeb, 'agebCDMX', agebStyle);
        loadGeoJsonLayer('ageb_edomex.geojson', geoJsonLayersAgeb, 'agebEdoMex', agebStyle);
        loadGeoJsonLayer('uso_suelo.geojson', geoJsonLayersUsoSuelo, 'usoSuelo', usoSueloStyle);
        loadGeoJsonLayer('alcaldias.geojson', geoJsonLayersAlcaldias, 'alcaldias', alcaldiasStyle);
        loadGeoJsonLayer('municipios.geojson', geoJsonLayersMunicipios, 'municipios', municipiosStyle);
        loadGeoJsonLayer('poligonos.geojson', geoJsonLayersPoligonos, 'poligonos', poligonosStyle);
        loadGeoJsonLayer('colonias.geojson', geoJsonLayersColonias, 'colonias', coloniasStyle);
        loadGeoJsonLayer('competencias.geojson', geoJsonLayersCompetencias, 'competencias', competenciasStyle);

        // Control de capas dinámico
        function updateLayerControl() {
            if (layerControlContainer._map) {
                layerControlContainer.remove(map);
            }
            
            layerControlContainer.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'layer-control-container');
                div.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="osmLayer" checked>
                        <label for="osmLayer">OpenStreetMap</label>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="googleRoadLayer">
                        <label for="googleRoadLayer">Google Road</label>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="googleHybridLayer">
                        <label for="googleHybridLayer">Google Hybrid</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="agebLayer" checked>
                        <label for="agebLayer">AGEB</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="usoSueloLayer">
                        <label for="usoSueloLayer">Uso de Suelo</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="alcaldiasLayer">
                        <label for="alcaldiasLayer">Alcaldías</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="municipiosLayer">
                        <label for="municipiosLayer">Municipios</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="poligonosLayer">
                        <label for="poligonosLayer">Polígonos</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="coloniasLayer">
                        <label for="coloniasLayer">Colonias</label>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="competenciasLayer">
                        <label for="competenciasLayer">Competencias</label>
                    </div>
                `;
                
                div.querySelector('#osmLayer').addEventListener('change', function() {
                    if (this.checked) {
                        map.addLayer(osmLayer);
                    } else {
                        map.removeLayer(osmLayer);
                    }
                });
                
                div.querySelector('#googleRoadLayer').addEventListener('change', function() {
                    if (this.checked) {
                        map.addLayer(googleRoadLayer);
                    } else {
                        map.removeLayer(googleRoadLayer);
                    }
                });
                
                div.querySelector('#googleHybridLayer').addEventListener('change', function(){
                    if (this.checked) {
                        map.addLayer(googleHybridLayer);
                    } else {
                        map.removeLayer(googleHybridLayer);
                    }
                });

                div.querySelector('#agebLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersAgeb.agebCDMX) map.addLayer(geoJsonLayersAgeb.agebCDMX);
                        if (geoJsonLayersAgeb.agebEdoMex) map.addLayer(geoJsonLayersAgeb.agebEdoMex);
                    } else {
                        if (geoJsonLayersAgeb.agebCDMX) map.removeLayer(geoJsonLayersAgeb.agebCDMX);
                        if (geoJsonLayersAgeb.agebEdoMex) map.removeLayer(geoJsonLayersAgeb.agebEdoMex);
                    }
                });

                div.querySelector('#usoSueloLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersUsoSuelo.usoSuelo) map.addLayer(geoJsonLayersUsoSuelo.usoSuelo);
                    } else {
                        if (geoJsonLayersUsoSuelo.usoSuelo) map.removeLayer(geoJsonLayersUsoSuelo.usoSuelo);
                    }
                });

                div.querySelector('#alcaldiasLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersAlcaldias.alcaldias) map.addLayer(geoJsonLayersAlcaldias.alcaldias);
                    } else {
                        if (geoJsonLayersAlcaldias.alcaldias) map.removeLayer(geoJsonLayersAlcaldias.alcaldias);
                    }
                });

                div.querySelector('#municipiosLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersMunicipios.municipios) map.addLayer(geoJsonLayersMunicipios.municipios);
                    } else {
                        if (geoJsonLayersMunicipios.municipios) map.removeLayer(geoJsonLayersMunicipios.municipios);
                    }
                });

                div.querySelector('#poligonosLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersPoligonos.poligonos) map.addLayer(geoJsonLayersPoligonos.poligonos);
                    } else {
                        if (geoJsonLayersPoligonos.poligonos) map.removeLayer(geoJsonLayersPoligonos.poligonos);
                    }
                });

                div.querySelector('#coloniasLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersColonias.colonias) map.addLayer(geoJsonLayersColonias.colonias);
                    } else {
                        if (geoJsonLayersColonias.colonias) map.removeLayer(geoJsonLayersColonias.colonias);
                    }
                });

                div.querySelector('#competenciasLayer').addEventListener('change', function() {
                    if (this.checked) {
                        if (geoJsonLayersCompetencias.competencias) map.addLayer(geoJsonLayersCompetencias.competencias);
                    } else {
                        if (geoJsonLayersCompetencias.competencias) map.removeLayer(geoJsonLayersCompetencias.competencias);
                    }
                });
                
                return div;
            };
            
            layerControlContainer.addTo(map);
        }

        // Localización en tiempo real
        let watchId = null;
        let realtimeMarker = null;
        const realtimeLocationBtn = document.getElementById('realtime-location-button');
        const useLocationBtn = document.getElementById('useLocationBtn');
        let isRealtimeLocationActive = false;
        let lastAccuracy = null;

        realtimeLocationBtn.addEventListener('click', () => {
            if (isRealtimeLocationActive) {
                stopRealtimeLocation();
            } else {
                startRealtimeLocation();
            }
        });

        useLocationBtn.addEventListener('click', () => {
            if (realtimeMarker) {
                const latLng = realtimeMarker.getLatLng();
                document.getElementById('lat').value = latLng.lat;
                document.getElementById('lon').value = latLng.lng;
                stopRealtimeLocation();
            } else {
                alert("La localización en tiempo real no está activa.");
            }
        });

        function startRealtimeLocation() {
            if (navigator.geolocation) {
                realtimeLocationBtn.style.backgroundColor = 'lightgreen'; // Cambiar color del botón
                isRealtimeLocationActive = true;
                
                watchId = navigator.geolocation.watchPosition(
                    position => {
                        updateRealtimeLocation(position);
                        lastAccuracy = position.coords.accuracy;
                        console.log(`Precisión de la localización: ${lastAccuracy} metros`);
                        alert(`Localización activada. Precisión: ${lastAccuracy} metros`);
                    },
                    error => {
                        handleLocationError(error);
                        stopRealtimeLocation();
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 1000 }
                );
            } else {
                alert("La geolocalización no es compatible con este navegador.");
            }
        }

        function stopRealtimeLocation() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            if (realtimeMarker) {
                map.removeLayer(realtimeMarker);
                realtimeMarker = null;
            }
            realtimeLocationBtn.style.backgroundColor = 'white'; // Restaurar color del botón
            isRealtimeLocationActive = false;
            console.log("Localización desactivada.");
            alert("Localización desactivada.");
        }

        function updateRealtimeLocation(position) {
            const latLng = L.latLng(position.coords.latitude, position.coords.longitude);
            if (realtimeMarker) {
                realtimeMarker.setLatLng(latLng);
            } else {
                realtimeMarker = L.marker(latLng).addTo(map);
            }
            map.setView(latLng, 18);
        }

        function handleLocationError(error) {
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    alert("Permiso de geolocalización denegado.");
                    break;
                case error.POSITION_UNAVAILABLE:
                    alert("Información de ubicación no disponible.");
                    break;
                case error.TIMEOUT:
                    alert("Tiempo de espera agotado.");
                    break;
                case error.UNKNOWN_ERROR:
                    alert("Ocurrió un error desconocido.");
                    break;
            }
        }
    </script>
</body>
</html>
