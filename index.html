<!DOCTYPE html>
<html lang="es">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdn.jsdelivr.net; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com; img-src 'self' data: https://cdn.jsdelivr.net https://raw.githubusercontent.com https://tile.openstreetmap.org *.google.com https://github.com maps.googleapis.com *.gstatic.com mapstreet.com mt1.google.com mt0.google.com *.khms.googleapis.com; font-src 'self' data: https://cdn.jsdelivr.net; connect-src 'self' https://nominatim.openstreetmap.org;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa interactivo Tiendas 3B</title>
    <link rel="icon" href="favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <style>
        html, body { height: 100%; margin: 0; }
        #map { width: 100%; height: 100%; }
        .red-marker {background-color: Red; border: 3px solid white; border-radius: 50%; width: 20px; height: 20px; display: inline-block; }
        .marker-label { position: absolute; top: -40px; left: 50%; transform: translateX(-50%); color: red; text-shadow: 1px 1px 0 white, -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white; font-weight: bold; font-size: 14px; white-space: nowrap; padding: 5px; }
        #side-form {
            display: none; 
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            position: fixed;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            z-index: 1001;
        }
        #side-form.active {
            display: block;
        }
        #form-toggle-btn {
            position: fixed;
            left: 0; 
            top: 50%;
            transform: translateY(-50%);
            background-color: #e0e0e0;
            border: none;
            border-radius: 0 70% 70% 0; 
            width: 40px; 
            height: 65px; 
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; 
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            background-color: white; 
        }
        #close-form-btn {
            background-color: #e0e0e0;
            border: none;
            padding: 6px;
            cursor: pointer;
            margin-top: 8px;
            border-radius: 4px;
            width: 100%;
        }
        #center-button, #realtime-location-button, #competencias-button {
            position: absolute;
            z-index: 1000;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            padding: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #center-button { bottom: 60px; left: 10px; }
        #realtime-location-button { bottom: 106px; left: 10px; }
        #competencias-button { bottom: 152px; left: 10px; }
        #zoom-level {
            background-color: rgb(255, 255, 255);
            color: black;
            border-radius: 2px;
            padding: 7px;
            cursor: default;
            text-align: center;
            font-weight: bold;
            position: absolute;
            top: 75px;
            left: 12px;
            z-index: 1000;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            width: 15.5px;
            height: 15.5px;
        }
        .form-container { padding: 8px; }
        .form-row { display: flex; flex-direction: column; }
        .form-row label { font-weight: bold; margin-bottom: 3px; font-size: 0.9em; }
        .form-row input { padding: 4px; margin-bottom: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; }
        .button-container { display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; margin-top: 8px; }
        .button-container button { padding: 6px; border: none; border-radius: 4px; background-color: red; color: white; cursor: pointer; font-size: 0.85em; }
        .button-container button:hover { background-color: #d60420; }
        .logo { display: block; margin: 0 auto 8px; width: 50px; }
        .centered-title { text-align: center; margin: 8px 0; font-size: 1em; }
    </style>
</head>
<body>
    <button id="form-toggle-btn" title="Abrir/Cerrar formulario" aria-label="Abrir/Cerrar formulario">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#3c4043" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12h18h18M3 18h18" />
        </svg>
    </button>
    <div id="side-form">
        <div class="header-container">
            <h1 class="centered-title">Mapa interactivo Tiendas 3B</h1>
            <img src="https://raw.githubusercontent.com/Dchable16/Mapa_interactivo/main/Captura-removebg-preview.png" alt="Logotipo" class="logo">
        </div>
        <div class="form-container">
            <div class="form-row">
                <label for="lat">Latitud:</label>
                <input type="text" id="lat" value="19.4326">
                <label for="lon">Longitud:</label>
                <input type="text" id="lon" value="-99.1332">
                <label for="markerName">Nombre del Marcador:</label>
                <input type="text" id="markerName" value="Marcador Manual">
            </div>
            <div class="button-container">
                <button onclick="addMarker()">Agregar Marcador</button>
                <button onclick="removeMarker()">Eliminar Marcador</button>
                <button onclick="createRadiosAndDifference()">Crear Radios</button>
                <button onclick="extractAgebData()">Extraer Datos Ageb</button>
                <button id="useLocationBtn">Usar Localización</button>
                <button id="download-report-btn">Descarga Reporte</button>
            </div>
        </div>
        <button id="close-form-btn" aria-label="Cerrar formulario">Cerrar</button>
    </div>
    <div id="map" style="position: relative;">
        <div id="zoom-level" title="Nivel del Zoom">
            <span id="zoom-value">12</span>
        </div>
        <button id="center-button" title="Centrar en el marcador" aria-label="Centrar en el marcador">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3c4043" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3" fill="#3c4043" />
                <path d="M12 2v2M2 12h2M12 22v-2M22 12h-2M12 6v-2M6 12h-2M12 18v2M18 12h2" />
            </svg>
        </button>
        <button id="competencias-button" title="Competencias comerciales" aria-label="Competencias comerciales">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3c4043" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        </button>
        <div class="loading-indicator" id="loading-indicator">Buscando puntos de interés...</div>
        <button id="realtime-location-button" title="Localización en tiempo real" aria-label="Localización en tiempo real">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3c4043" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10" fill="none" stroke="#3c4043" stroke-width="2" />
                <circle cx="12" cy="12" r="3" fill="#3c4043" />
            </svg>
        </button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script>
     // Inicializar el mapa centrado en las coordenadas especificadas
    const map = L.map("map").setView([19.4326, -99.1332], 12);
    const formToggleBtn = document.getElementById('form-toggle-btn');
    const sideForm = document.getElementById('side-form');
    const closeFormBtn = document.getElementById('close-form-btn');

    formToggleBtn.addEventListener('click', () => {
        sideForm.classList.toggle('active');
    });

    closeFormBtn.addEventListener('click', () => {
        sideForm.classList.remove('active');
    });

    // Inicializar el contenedor de control de capas
    const layerControlContainer = L.control({ position: 'topright' });

    let debounceTimer;
    map.on('zoomend', function() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            const currentZoom = map.getZoom();
            document.getElementById('zoom-value').textContent = currentZoom;

            // Mostrar u ocultar etiquetas según el nivel de zoom
            Object.values(geoJsonLayersAgeb).forEach(layer => {
                layer.eachLayer(function(marker) {
                    currentZoom < 16 ? marker.closeTooltip() : marker.openTooltip();
                });
            });
        }, 300);
    });

    // Agregar el control de escala dinámica al mapa
    L.control.scale({
        position: 'bottomleft',
        metric: true,
        imperial: false
    }).addTo(map);

    // Función para centrar el mapa en el marcador
    document.getElementById('center-button').addEventListener('click', function() {
        if (currentMarker) {
            map.setView(currentMarker.getLatLng(), map.getZoom());
        } else {
            alert("No hay ningún marcador en el mapa para centrar.");
        }
    });

    // Capas base del mapa
    const osmLayer = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; <a href='https://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors"
    }).addTo(map);

    const googleRoadLayer = L.tileLayer("https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}", { attribution: "Google" });
    const googleHybridLayer = L.tileLayer("https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", { attribution: "Google" });

    // Variables para el marcador y los radios
    let currentMarker = null;
    let radius400m = null;
    let radius800m = null;

    // Grupos de capas para los radios
    const radius400Layer = L.layerGroup().addTo(map);
    const radius800Layer = L.layerGroup().addTo(map);

    // Función para agregar un marcador en el mapa
    function addMarker() {
        if (currentMarker) {
            alert("Ya existe un marcador en el mapa. Elimínelo antes de agregar uno nuevo.");
            return;
        }

        const lat = parseFloat(document.getElementById('lat').value);
        const lon = parseFloat(document.getElementById('lon').value);
        const markerName = document.getElementById('markerName').value;

        if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
            alert("Por favor ingrese coordenadas válidas.");
            return;
        }

        try {
            currentMarker = L.marker([lat, lon], {
                icon: L.divIcon({ className: 'red-marker', iconSize: [12, 12], iconAnchor: [10, 20] })
            }).addTo(map);

            const currentMarkerLabel = L.divIcon({
                className: 'marker-label',
                html: markerName,
                iconSize: [100, 50],
                iconAnchor: [50, 15]
            });
            L.marker([lat, lon], { icon: currentMarkerLabel }).addTo(map);
            map.setView([lat, lon], 12);
        } catch (error) {
            console.error("Error al agregar el marcador:", error);
            alert("Ocurrió un error al agregar el marcador. Verifique la consola para más detalles.");
        }
    }

    function removeMarker() {
        if (currentMarker) {
            map.removeLayer(currentMarker);
            currentMarker = null;
            document.getElementById('lat').value = '';
            document.getElementById('lon').value = '';
            document.getElementById('markerName').value = '';
        } else {
            alert("No hay ningún marcador para eliminar.");
        }
    }

    // Función para agregar radios de 400m o 800m alrededor del marcador
    function addRadius(radius) {
        if (!currentMarker) {
            alert("Primero debe agregar un marcador.");
            return;
        }

        const latLng = currentMarker.getLatLng();
        const circle = L.circle(latLng, { color: radius === 400 ? 'blue' : 'red', fillOpacity: 0.2, radius: radius });
        radius === 400 ? radius400Layer.addLayer(circle) : radius800Layer.addLayer(circle);
    }
    function calculateDifference() {
        if (currentMarker && radius400m && radius800m) {
            const latLng = currentMarker.getLatLng();
            const circle400 = turf.circle([latLng.lng, latLng.lat], 400, { units: 'meters' });
            const circle800 = turf.circle([latLng.lng, latLng.lat], 800, { units: 'meters' });
            const difference = turf.difference(circle800, circle400);
            if (difference) {
                const geoJson = turf.featureCollection([difference]);
                L.geoJSON(geoJson, { style: { color: 'green', weight: 2, fillOpacity: 0.5 } }).addTo(differenceLayerGroup);
            } else {
                alert("No se pudo calcular la diferencia entre los círculos.");
            }
        } else {
            alert("Asegúrese de que el marcador y ambos radios estén creados.");
        }
    }

    function createRadiosAndDifference() {
        if (!currentMarker) {
            alert("Primero debe agregar un marcador.");
            return;
        }

        addRadius(400);
        addRadius(800);
        calculateDifference();
    }

    function extractAgebData() {
        if (!currentMarker) {
            alert("Primero debe agregar un marcador.");
            return;
        }

        extractBufferData();
        extractDifferenceData();
    }

    function extractBufferData() {
        if (currentMarker) {
            const latLng = currentMarker.getLatLng();
            const point = turf.point([latLng.lng, latLng.lat]);
            let selectedLayer = findLayerContainingPoint(point);

            if (selectedLayer) {
                const buffer = turf.circle([latLng.lng, latLng.lat], 400, { units: 'meters' });
                const featuresWithinBuffer = turf.featureCollection(selectedLayer.features.map(feature => {
                    const intersection = turf.intersect(feature, buffer);
                    if (intersection) {
                        addPropertiesToIntersection(intersection, feature);
                        return intersection;
                    }
                    return null;
                }).filter(feature => feature !== null));

                L.geoJSON(featuresWithinBuffer, {
                    style: { color: 'orange', weight: 2, fillOpacity: 0.5 },
                    onEachFeature: function (feature, layer) {
                        layer.bindTooltip(feature.properties.POB1.toString(), {
                            permanent: true,
                            direction: 'center',
                            className: 'ageb-label'
                        }).openTooltip();
                    }
                }).addTo(bufferLayerGroup);
            } else {
                alert("El marcador no está dentro de ninguna capa AGEB.");
            }
        } else {
            alert("Primero debe agregar un marcador.");
        }
    }

    function extractDifferenceData() {
        if (currentMarker) {
            const latLng = currentMarker.getLatLng();
            const point = turf.point([latLng.lng, latLng.lat]);
            let selectedLayer = findLayerContainingPoint(point);

            if (selectedLayer) {
                const circle400 = turf.circle([latLng.lng, latLng.lat], 400, { units: 'meters' });
                const circle800 = turf.circle([latLng.lng, latLng.lat], 800, { units: 'meters' });
                const difference = turf.difference(circle800, circle400);

                const featuresWithinDifference = turf.featureCollection(selectedLayer.features.map(feature => {
                    const intersection = turf.intersect(feature, difference);
                    if (intersection) {
                        addPropertiesToIntersection(intersection, feature);
                        return intersection;
                    }
                    return null;
                }).filter(feature => feature !== null));

                L.geoJSON(featuresWithinDifference, {
                    style: { color: 'purple', weight: 2, fillOpacity: 0.5 },
                    onEachFeature: function (feature, layer) {
                        layer.bindTooltip(feature.properties.POB1.toString(), {
                            permanent: true,
                            direction: 'center',
                            className: 'ageb-label'
                        }).openTooltip();
                    }
                }).addTo(differenceExtractionLayerGroup);
            } else {
                alert("El marcador no está dentro de ninguna capa AGEB.");
            }
        } else {
            alert("Asegúrese de que el marcador esté creado.");
        }
    }

    function findLayerContainingPoint(point) {
        if (agebCDMXLayer && agebCDMXLayer.toGeoJSON().features.some(feature => turf.booleanPointInPolygon(point, feature))) {
            return agebCDMXLayer.toGeoJSON();
        }
        if (agebEdoMexLayer && agebEdoMexLayer.toGeoJSON().features.some(feature => turf.booleanPointInPolygon(point, feature))) {
            return agebEdoMexLayer.toGeoJSON();
        }
        return null;
    }

    function addPropertiesToIntersection(intersection, feature) {
        const originalArea = Math.floor(turf.area(feature));
        const extractedArea = Math.floor(turf.area(intersection));
        const extractionPercentage = (extractedArea / originalArea);
        const populationTotal = (extractionPercentage * feature.properties.POB1);

        intersection.properties.POB1 = feature.properties.POB1;
        intersection.properties.originalArea = originalArea;
        intersection.properties.extractedArea = extractedArea;
        intersection.properties.extractionPercentage = extractionPercentage;
        intersection.properties.populationTotal = Math.floor(populationTotal);
    }
    function generateReport() {
        if (ageb400Data.length === 0 && ageb800Data.length === 0) {
            alert("No hay datos para generar el reporte.");
            return;
        }

        let csvContent = "data:text/csv;charset=utf-8,";
        
        // Encabezados para AGEB 400m
        if (ageb400Data.length > 0) {
            csvContent += "AGEB 400m\n";
            csvContent += "POB1,Area_original,Area_Extraida,Porcentaje_Area,Poblacion_Total\n";
            ageb400Data.forEach(item => {
                csvContent += `${item.POB1},${item.originalArea},${item.extractedArea},${item.extractionPercentage},${item.populationTotal}\n`;
            });
            csvContent += "\n";
        }

        // Encabezados para AGEB 800m
        if (ageb800Data.length > 0) {
            csvContent += "AGEB 800m\n";
            csvContent += "POB1,Area_original,Area_Extraida,Porcentaje_Area,Poblacion_Total\n";
            ageb800Data.forEach(item => {
                csvContent += `${item.POB1},${item.originalArea},${item.extractedArea},${item.extractionPercentage},${item.populationTotal}\n`;
            });
        }

        // Crear un enlace de descarga
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "reporte_ageb.csv");
        document.body.appendChild(link);
        link.click();
    }

    // Función para cargar capas GeoJSON desde archivos bajo demanda
    function loadLayer(layerName, type) {
        const layerUrls = {
            'Ageb CDMX': 'Ageb_urb_CDMX.geojson',
            'Ageb Edo. Mex.': 'Ageb_urb_Edo_Mex.geojson',
            'Uso de suelo Centro Barrio': 'Uso_suelo_centro_barrio.geojson',
            'Alcaldías CDMX': 'Alcaldias_Ciudad_de_México.geojson',
            // Agregar más capas según sea necesario
        };

        if (layerUrls[layerName]) {
            loadGeoJSON(layerUrls[layerName], layerName, type);
        } else {
            console.error('URL de capa no encontrada para:', layerName);
        }
    }

    // Función para cargar GeoJSON
    function loadGeoJSON(url, layerName, type) {
        if (loadedLayers.has(layerName)) {
            console.log(`La capa ${layerName} ya ha sido cargada.`);
            return;
        }

        fetch(url)
            .then(response => {
                if (!response.ok) throw new Error(`Error al cargar ${url}: ${response.statusText}`);
                return response.json();
            })
            .then(data => {
                const geoJsonLayer = L.geoJSON(data, {
                    pointToLayer: function(feature, latlng) {
                        return L.marker(latlng, { icon: iconosPersonalizados[feature.properties.layerName] || defaultIcon });
                    },
                    style: (feature) => {
                        return { color: 'blue', weight: 2, fillOpacity: 0.5 };
                    },
                    onEachFeature: (feature, layer) => {
                        layer.on('click', () => {
                            let popupContent = "<b>Atributos:</b><br>";
                            for (const key in feature.properties) {
                                popupContent += `${key}: ${feature.properties[key]}<br>`;
                            }
                            layer.bindPopup(popupContent).openPopup();
                        });
                    }
                }).addTo(map);

                loadedLayers.add(layerName);
            })
            .catch(err => console.error('Error al cargar GeoJSON:', err));
    }
    // Localización en tiempo real
    let watchId = null;
    let realtimeMarker = null;
    const realtimeLocationBtn = document.getElementById('realtime-location-button');
    const useLocationBtn = document.getElementById('useLocationBtn');
    let isRealtimeLocationActive = false;

    realtimeLocationBtn.addEventListener('click', () => {
        isRealtimeLocationActive ? stopRealtimeLocation() : startRealtimeLocation();
    });

    useLocationBtn.addEventListener('click', () => {
        if (realtimeMarker) {
            const latLng = realtimeMarker.getLatLng();
            document.getElementById('lat').value = latLng.lat;
            document.getElementById('lon').value = latLng.lng;
            stopRealtimeLocation();
        } else {
            alert("La localización en tiempo real no está activa.");
        }
    });

    function startRealtimeLocation() {
        if (navigator.geolocation) {
            isRealtimeLocationActive = true;
            navigator.geolocation.getCurrentPosition(
                initialPosition => {
                    updateRealtimeLocation(initialPosition);
                    watchId = navigator.geolocation.watchPosition(
                        position => updateRealtimeLocation(position),
                        error => handleLocationError(error),
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                    );
                },
                error => handleLocationError(error)
            );
        } else {
            alert("La geolocalización no es compatible con este navegador.");
        }
    }

    function stopRealtimeLocation() {
        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
            watchId = null;
        }
        if (realtimeMarker) {
            map.removeLayer(realtimeMarker);
            realtimeMarker = null;
        }
        isRealtimeLocationActive = false;
    }

    function updateRealtimeLocation(position) {
        const currentLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
        if (realtimeMarker) {
            realtimeMarker.setLatLng(currentLatLng);
        } else {
            realtimeMarker = L.marker(currentLatLng).addTo(map);
        }
        map.setView(currentLatLng, 18);
    }

    function handleLocationError(error) {
        switch (error.code) {
            case error.PERMISSION_DENIED:
                alert("Permiso de geolocalización denegado.");
                break;
            case error.POSITION_UNAVAILABLE:
                alert("Información de ubicación no disponible.");
                break;
            case error.TIMEOUT:
                alert("Tiempo de espera agotado.");
                break;
            case error.UNKNOWN_ERROR:
                alert("Ocurrió un error desconocido.");
                break;
        }
    }

    // Código para manejar puntos de interés
    const competenciasButton = document.getElementById('competencias-button');
    const loadingIndicator = document.getElementById('loading-indicator');
    let poiMarkers = L.markerClusterGroup().addTo(map);

    competenciasButton.addEventListener('click', () => {
        if (currentMarker) {
            findNearbyPOIs(currentMarker.getLatLng());
        } else {
            alert("Primero debe agregar un marcador.");
        }
    });

    function findNearbyPOIs(latlng) {
        poiMarkers.clearLayers();
        loadingIndicator.style.display = 'block';

        const categories = {
            'hospital': { query: 'hospital or clinica', icon: 'hospital_icon_url' },
            'marketplace': { query: 'Mercado', icon: 'market_icon_url' },
            '3B': { query: 'Tienda 3B', icon: '3B_icon_url' },
            'neto': { query: 'Tienda neto', icon: 'neto_icon_url' },
            'school': { query: 'Escuela', icon: 'school_icon_url' },
            'church': { query: 'Iglesia', icon: 'church_icon_url' },
            'bodega aurrera': { query: 'Bodega Aurrera', icon: 'bodega_icon_url' }
        };

        let promises = [];
        let delay = 500;

        Object.entries(categories).forEach(([category, data]) => {
            const encodedQuery = encodeURIComponent(data.query);
            const viewbox = `${latlng.lng - 0.01},${latlng.lat - 0.01},${latlng.lng + 0.01},${latlng.lat + 0.01}`;
            const url = `https://nominatim.openstreetmap.org/search?q=${encodedQuery}&format=geojson&viewbox=${viewbox}&bounded=1&limit=10`;

            promises.push(new Promise((resolve) => {
                setTimeout(() => {
                    fetch(url)
                        .then(response => {
                            if (!response.ok) throw new Error(`Error en la solicitud: ${response.status}`);
                            return response.json();
                        })
                        .then(data => resolve({ ...data, category }))
                        .catch(error => {
                            console.error("Error al buscar puntos de interés:", error);
                            resolve(null);
                        });
                }, delay);
                delay += 500;
            }));
        });

        Promise.all(promises).then(results => {
            results.filter(result => result).forEach(result => {
                if (result && result.features) {
                    result.features.forEach(feature => {
                        const icon = L.icon({
                            iconUrl: categories[result.category].icon,
                            iconSize: [25, 25],
                            iconAnchor: [16, 32],
                            popupAnchor: [0, -32]
                        });

                        const marker = L.marker([feature.geometry.coordinates[1], feature.geometry.coordinates[0]], { icon });
                        marker.bindPopup(`<b>${feature.properties.display_name}</b><br>Dirección: ${feature.properties.display_name}<br>Coordenadas: ${feature.geometry.coordinates[1]}, ${feature.geometry.coordinates[0]}`);
                        poiMarkers.addLayer(marker);
                    });
                }
            });
            loadingIndicator.style.display = 'none';
        }).catch(error => {
            console.error("Error general al buscar puntos de interés:", error);
            alert("Ocurrió un error al buscar puntos de interés cercanos.");
            loadingIndicator.style.display = 'none';
        });
    }
    // Función para cargar capas GeoJSON desde archivos bajo demanda
    function loadLayer(layerName, type) {
        const layerUrls = {
            'Ageb CDMX': 'Ageb_urb_CDMX.geojson',
            'Ageb Edo. Mex.': 'Ageb_urb_Edo_Mex.geojson',
            'Uso de suelo Centro Barrio': 'Uso_suelo_centro_barrio.geojson',
            'Alcaldías CDMX': 'Alcaldias_Ciudad_de_México.geojson',
            // Agregar más capas según sea necesario
        };

        if (layerUrls[layerName]) {
            loadGeoJSON(layerUrls[layerName], layerName, type);
        } else {
            console.error('URL de capa no encontrada para:', layerName);
        }
    }

    // Función para cargar GeoJSON
    function loadGeoJSON(url, layerName, type) {
        if (loadedLayers.has(layerName)) {
            console.log(`La capa ${layerName} ya ha sido cargada.`);
            return;
        }

        fetch(url)
            .then(response => {
                if (!response.ok) throw new Error(`Error al cargar ${url}: ${response.statusText}`);
                return response.json();
            })
            .then(data => {
                const geoJsonLayer = L.geoJSON(data, {
                    pointToLayer: function(feature, latlng) {
                        return L.marker(latlng, { icon: iconosPersonalizados[feature.properties.layerName] || defaultIcon });
                    },
                    style: (feature) => {
                        return { color: 'blue', weight: 2, fillOpacity: 0.5 };
                    },
                    onEachFeature: (feature, layer) => {
                        layer.on('click', () => {
                            let popupContent = "<b>Atributos:</b><br>";
                            for (const key in feature.properties) {
                                popupContent += `${key}: ${feature.properties[key]}<br>`;
                            }
                            layer.bindPopup(popupContent).openPopup();
                        });
                    }
                }).addTo(map);

                loadedLayers.add(layerName);
            })
            .catch(err => console.error('Error al cargar GeoJSON:', err));
    }
    // Función para manejar el evento de clic en el botón de descarga del reporte
    document.getElementById('download-report-btn').addEventListener('click', generateReport);

    // Función para manejar el evento de clic en el botón de competencias
    competenciasButton.addEventListener('click', () => {
        if (currentMarker) {
            findNearbyPOIs(currentMarker.getLatLng());
        } else {
            alert("Primero debe agregar un marcador.");
        }
    });

    // Función para inicializar el mapa y cargar las capas necesarias al inicio
    function initializeMap() {
        loadLayer('Ageb CDMX', 'Ageb');
        loadLayer('Ageb Edo. Mex.', 'Ageb');
        loadLayer('Uso de suelo Centro Barrio', 'UsoSuelo');
        loadLayer('Alcaldías CDMX', 'Alcaldias');
        // Agregar más capas según sea necesario
    }

    // Llamar a la función de inicialización al cargar el documento
    document.addEventListener('DOMContentLoaded', initializeMap);    
</script>
</body>
</html>
